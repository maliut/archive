# 文档
功能：对一个命题进行表证明（可能带有前件），按顺序给出每次处理的表值。
并在最后判断是否表可证或表可反驳，若表可反驳则给出一个反例。

## 使用方法
使用环境：Eclipse + JRE8<br>
在工程目录下 propositions.txt 中按照文档的格式输入命题<br>
propositions2.txt，propositions3.txt 等为另外的测试用例，可重命名后使用。<br>
运行程序，则会在 output.txt 中输出结果<br>
结果中前面是按照文档输出的 entry 处理顺序，最后一行是该命题是否为表可证，若不可证则给出一个反例。<br>
注意：
- propositions.txt 中只能包含一个（可能带前件的）命题。因为带前件的命题会有多行，因此并不设定为一行处理一个命题。
- 每个命题需要为 well-defined，若不是，则会在命令行中提示非 well-defined，output.txt 不会有输出。

## 设计
### 构造 CST
1. 将文本形式的命题解析成树。这里没有用提供的库，而是沿用了 lab1 的代码将每个命题完全解析之。
2. 构建表证明的 CST，将需要证明的命题添加到树上作为根节点。
3. 为 CST 上每个节点维护一个字典序。
4. 维护一个“已归约表值”的列表。若该表值所在路径上存在相同表值且在此列表中则说明其已被归约。
5. 进行“归约”步骤。按字典序，取出最小的且未被归约过的表值进行“归约”步骤。
若其没有被归约且可以归约，则将其重新引入，按照原子表归约之，并加入 CST。
6. 进行“引入”步骤，若仍存在尚未引入的前件，则将其添加到所有 CST 的叶节点之下，否则跳过。
7. 重复步骤5、6，直至所有节点都被标记为“已归约”，说明所有表值均已被归约。由于输入方式的限制并不用考虑无穷的情况。

### 进行证明
1. 每次将一个表值添加到树上时，从下至上遍历当前路径，判断该路径是否矛盾。
2. 若当前路径矛盾，则为引发矛盾的叶节点标记“已矛盾”。
当增加新的节点到树上时，被标记为“已矛盾”的节点下不再加入新节点。
3. 在引入或重新引入的步骤，遍历树取得叶节点时，排除被标记为“已矛盾”的叶节点。
4. 若遍历树是从根节点开始，且无法找到没有被标记为“已矛盾”的叶节点，则说明所有路径均矛盾。
因此表可证，输出结果并退出。
5. 若整棵树构造完毕而仍未结束程序，则说明存在反例。任取一条非矛盾路径，该路径上的节点必被完全归约。
遍历这条路径，输出其上所有由命题字母构成的表值作为反例。